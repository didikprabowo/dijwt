package main

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strings"
)

type Header struct {
	Alg string `json:"alg"`
	Typ string `json:"typ"`
}

var AlgoJWT = "HS256"
var secret = []byte("didikprabowoganteng")

func main() {
	header := Header{
		"HS256",
		"JWT",
	}

	payload := map[string]interface{}{
		"name": "didikganteng",
	}
	GenereteJWT(AlgoJWT, header, payload)
}

func GenereteJWT(algo string, Header interface{}, Payload interface{}) {

	header, _ := base64Encode(Header)
	payload, _ := base64Encode(Payload)
	payloads := make(map[string]string)
	payloads["header"] = header
	payloads["payload"] = payload
	jsonBytes, err := json.Marshal(payloads)
	if err != nil {
		panic(err)
	}

	signature := signString(jsonBytes, secret)

	signatureEncoded := base64.URLEncoding.EncodeToString(signature)
	tokens := fmt.Sprintf(header + "." + payload + "." + signatureEncoded)
	fmt.Println(tokens)

	fmt.Println(verifyJWT(AlgoJWT, tokens))
}
func base64Encode(payload interface{}) (string, error) {
	tobytes, err := json.Marshal(&payload)
	if err != nil {
		return "", err
	}
	dataPayload := base64.URLEncoding.EncodeToString([]byte(tobytes))
	return dataPayload, nil
}

func base64Decodes(s string) []byte {
	data2, err := base64.URLEncoding.DecodeString(s)
	if err != nil {
		panic(err)
	}
	return data2
}

func signString(stringToSign []byte, sharedSecret []byte) []byte {
	h := hmac.New(sha256.New, sharedSecret)
	h.Write(stringToSign)

	return h.Sum(nil)
}
func verifyJWT(algo string, jwt string) bool {
	result := strings.Split(jwt, ".")
	dataEncoded := result[0] + result[1]
	signature := base64Decodes(dataEncoded)
	rawsignature := signString(base64Decodes(dataEncoded), secret)

	return verifyString(rawsignature, signature)
}
func verifyString(stringToVerify []byte, signature []byte) bool {

	h := hmac.New(sha256.New, secret)
	h.Write(stringToVerify)
	calculated := h.Sum(nil)
	return hmac.Equal(calculated, signature)
}
